/*
Package goroutinePool 为了避免多个goroutine耗尽系统资源因此使用协程池来管理协程。
1.协程的数量可以指定
2.返回结果状态
3.工作并发控制。当前运行工作数<=协程的数量
在 Golang 中，Channel 是语言级支持的一种数据类型，实现了协程间基于消息传递的通信方式，是线程安全的。
这里先将原始的任务数据以某种统一的数据结构 (RawTask) 统一推入到 Channel 管道中，即形成了一个原任务 Channel。
启动指定数量的工作协程，对 Channel 中的任务数据进行抢占式消费，即在所有的工作协程中，谁抢到任务谁处理，处理完成后，
将处理结果以某种统一的数据结构 (RetTask) 写入另一个结果 Channel 中，然后再继续获取原任务进行执行，
如果工作协程发现原任务队列已为空，则协程退出。 这种方式不会给任何工作协程分配指定数量的任务，这样效率高的可以多处理，
效率低的允许少处理，从总体上达到处理时间最小化。 等待所有任务处理完成后，将处理结果数据统一返回上到层调用逻辑。
*/
package goroutinePool

func main() {

}
